#! /usr/bin/env python

"""
Script that does a find-and-replace across multiple files.  Similar to
'perl -p -i -e' with more features.

By default, this program prints the names of the changed files.
"""

import collections
import optparse
import sys
import tempfile
import os
import re
import shutil
from urllib import quote_plus


TEMP_FILE_PREFIX = "gsub"
TEMP_FILE_SUFFIX = ".tmp"
BACKUP_BASE = os.path.expanduser("~/.cache/gsub")



def main():
  options = parse_args()
  file_list = build_file_list(options)
  sanity_check(file_list, options)
  for filename in file_list:
    process_file(filename, options)



def parse_args():
  p = optparse.OptionParser("""\
usage: %prog [OPTIONS] PATTERN REPLACEMENT FILE...

PATTERN is a Python/Perl-style regular expression.  REPLACEMENT may
contain backreferences (\\1, \\2, etc.)
""")
  p.add_option("-i", "--backup-suffix", metavar="SUFFIX",
               help="create backup file by appending SUFFIX (like perl -i)")
  p.add_option("-F", "--fixed-strings", action="store_true",
               help="treat PATTERN and REPLACEMENT as literal strings (like grep -F)")
  p.add_option("-l", "--count-changed-lines", action="store_true",
               help="print the number of lines changed in each file")
  p.add_option("--force", action="store_true",
               help="ignore sanity checks")
  p.add_option("-n", "--diff", action="store_true",
               help="write a diff to standard out; don't modify any files")
  p.add_option("-k", "--keep-going", action="store_true",
               help="continue procressing of some files fail santity checks")
  p.add_option("--dereference", action="store_true")

  options, args = p.parse_args()
  if len(args) < 3:
    p.error("Not enough arguments.")

  options.context = 3
  options.pattern = args[0]
  options.replacement = args[1]
  options.files = args[2:]

  options.backup_dir = None
  if not options.diff:
    if not os.path.isdir(BACKUP_BASE):
      os.makedirs(BACKUP_BASE)
    new_id = 0
    for name in os.listdir(BACKUP_BASE):
      try:
        old_id = int(name)
      except ValueError:
        pass
      new_id = max(new_id, old_id + 1)
    options.backup_dir = os.path.join(BACKUP_BASE, str(new_id))

  return options



def build_file_list(options):
  result = []

  def process(path):
    if options.dereference or not os.path.islink(path):
      if os.path.isdir(path):
        if options.recursive:
          for entry in os.listdir(path):
            process(os.path.join(path, entry))
      elif not is_backup_file(path, options):
        result.append(path)

  for filename in options.files:
    process(filename)

  return result



def trace(message):
  sys.stderr.write("%s\n" % message)



def warn(message):
  sys.stderr.write("warning: %s\n" % message)



class ErrorProcessingFile(Exception): pass



def fail(message):
  """Print a warning message to stderr and abort processing the
  current file."""
  raise ErrorProcessingFile(message)



def process_file(filename, options):
  """Process a file names `filename` according to the settings in
  `options`."""

  lines_changed = 0

  if options.diff:
    input_file = open(filename, "rt")
    try:
      lines_changed = process_file_content(input_file, None, options)
    finally:
      input_file.close()
  else:
    try:
      # Create the backup file if necessary.
      backup_filename = None
      if options.backup_suffix:
        backup_filename = filename + options.backup_suffix
        try:
          os.link(filename, backup_filename)
        except OSError:
          fail("backup file already exists: %s" % backup_filename)

      try:
        lines_changed = process_file_nobackup(filename, options)
      finally:
        if backup_filename and not lines_changed:
          os.unlink(backup_filename)
    except:
      x = sys.exc_info()[1]
      sys.stderr.write("error processing " + filename + ": " + str(x) + "\n")
      raise

  if options.diff:
    if lines_changed:
      print "---", filename
      print "+++", filename
      for segment in merge_adjacent(lines_changed):
        segment.write(sys.stdout)
  elif options.count_changed_lines:
    print "%s: %d" % (filename, len(lines_changed))
  elif lines_changed:
    print filename


def process_file_nobackup(filename, options):
  """Process the file named `filename` without making a backup file."""

  # Open a temporary file.
  temp_fd, temp_filename = tempfile.mkstemp(suffix=TEMP_FILE_SUFFIX,
                                            prefix=TEMP_FILE_PREFIX,
                                            dir=os.path.dirname(filename),
                                            text=True)
  lines_changed = []
  try:
    temp_file = os.fdopen(temp_fd, "wt")
    try:
      input_file = open(filename, "rt")
      try:
        lines_changed = process_file_content(input_file, temp_file, options)
      finally:
        input_file.close()
    finally:
      temp_file.close()
  finally:
    if lines_changed:
      if options.backup_dir:
        if not os.path.isdir(options.backup_dir):
          os.mkdir(options.backup_dir)
        backup_filename = os.path.abspath(filename)
        head, sep, tail = backup_filename.partition(os.getenv("HOME") + "/")
        if sep != "" and head == "":
          backup_filename = tail
        backup_filename = quote_plus(backup_filename, "")
        backup_path = os.path.join(options.backup_dir, backup_filename)
        shutil.copy2(filename, backup_path)

      # Copy mode from the old file to the new file, taking care to
      # account for cases where the new file has a different owner.
      stat_in = os.stat(filename)
      stat_out = os.stat(temp_filename)
      new_mode = stat_in.st_mode & 0007
      if stat_in.st_gid == stat_out.st_gid:
        new_mode |= stat_in.st_mode & 0070
      if stat_in.st_uid == stat_out.st_uid:
        new_mode |= stat_in.st_mode & 0700
      os.chmod(temp_filename, new_mode)

      # Move the temp file into place.
      os.rename(temp_filename, filename)
    else:
      os.unlink(temp_filename)

  return lines_changed
  


def process_file_content(input, output, options):
  """Read lines from the file `input` and write the changed lines to
  `output`.  Returns the number of lines with changes."""

  lines_changed = []
  
  fixed_strings = options.fixed_strings
  replacement = options.replacement
  if fixed_strings:
    pattern = options.pattern
  else:
    pattern = re.compile(options.pattern)

  context_size = 3
  context_before = collections.deque([], context_size)
  last_change = None

  line_number = 0
  for old_line in input:
    line_number += 1

    if not old_line.endswith('\n'):
      old_line += '\n'

    if fixed_strings:
      new_line = old_line.replace(pattern, replacement)
    else:
      new_line = pattern.sub(replacement, old_line)

    segment = None
    if old_line != new_line:
      segment = DiffSegment.single_line(line_number,
                                        old_line,
                                        new_line,
                                        list(context_before))
      last_change = segment.changes[0]
      lines_changed.append(segment)
      context_before.clear()
    else:
      if last_change:
        last_change.context_after.append(new_line)
        if len(last_change.context_after) >= context_size:
          last_change = None
      context_before.append(new_line)

    if output is not None:
      output.write(new_line)

  return lines_changed



class DiffSegment(object):

  def __init__(self, changes):
    self.changes = list(changes)

  @staticmethod
  def single_line(
      line_number,
      old_line,
      new_line,
      context_before):
    return DiffSegment(
        [ChangedLines(line_number, context_before, [old_line], [new_line], [])])

  @property
  def first_change(self):
    return self.changes[0]

  @property
  def last_change(self):
    return self.changes[-1]

  @property
  def context_before(self):
    return self.first_change.context_before

  @property
  def context_after(self):
    return self.last_change.context_after

  @property
  def start_line(self):
    return self.first_change.start_line

  @property
  def end_line(self):
    return self.last_change.end_line

  def write(self, out):
    start = self.start_line - len(self.context_before)
    length = self.end_line - start + len(self.context_after)
    out.write("@@ -%d,%d +%d,%d @@\n" % (start, length, start, length))
    for change_set in self.changes:
      change_set.write(out)

  def merge_with(self, other):
    assert self.start_line < other.start_line
    if (self.last_change.context_end < other.first_change.context_start):
      return False

    to_delete = self.last_change.context_end - other.first_change.context_start
    if to_delete > 0:
      del self.last_change.context_after[-to_delete:]
      assert self.last_change.context_end == other.first_change.context_start
    self.changes = merge_adjacent(self.changes + other.changes)
    return True


class ChangedLines(object):

  def __init__(
      self,
      start_line,
      context_before,
      old_lines, new_lines,
      context_after):
    assert len(old_lines) == len(new_lines)
    self.start_line = start_line
    self.old_lines = old_lines
    self.new_lines = new_lines
    self.context_before = context_before
    self.context_after = context_after

  @property
  def end_line(self):
    return self.start_line + len(self.old_lines)

  @property
  def context_start(self):
    return self.start_line - len(self.context_before)

  @property
  def context_end(self):
    return self.end_line + len(self.context_after)

  def write(self, out):
    #out.write('a%d\n' % self.context_start)
    for line in self.context_before:
      out.write("  " + line)
    #out.write('b%d\n' % self.start_line)
    for line in self.old_lines:
      out.write("- " + line)
    for line in self.new_lines:
      out.write("+ " + line)
    for line in self.context_after:
      out.write("  " + line)
    #out.write('c%d\n' % self.context_end)

  def merge_with(self, other):
    if self.end_line != other.start_line:
      return False
    self.old_lines += other.old_lines
    self.new_lines += other.new_lines
    self.context_after = other.context_after
    return True



def merge_adjacent(items):
  """Merge adjacent items in a sequence using the items' `merge_with`
  method.  The `merge_with` method should either merge two items and
  return the merged item, or it should return None if the items cannot
  be merged."""
  items = list(items)
  i = 0
  while i + 1 < len(items):
    a, b = items[i:i+2]
    merged = a.merge_with(b)
    if merged:
      del items[i+1]
    else:
      i += 1
  return items



def sanity_check(file_list, options):
  if options.force:
    return

  abort = False
  bad_dirs = set()
  
  for path in file_list:
    dirname, filename = os.path.split(path)
    
    if ".#" + filename in os.listdir(dirname or "."):
      warn("%s appears to be modified in an emacs session" % path)
      abort = True

    for part in ["/.svn/", "/CVS/"]:
      if part in path:
        bad_dir = part[:path.index(part)] + part
        if bad_dir not in bad_dirs:
          warn("%s is in a version-control directory" % path)
          abort = True
          bad_dirs.add(bad_dir)
      
  if abort and not options.keep_going:
    sys.exit("aborted due to warnings")



def is_backup_file(filename, options):
  return options.backup_suffix and filename.endswith(options.backup_suffix)
  



if __name__ == "__main__": main()
