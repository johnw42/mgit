#! /usr/bin/env python

# This program prints a stack traces from a JVM crash.  The argument is a log
# file from a crashed JVM; if not given, the most recent log in the current
# directory is used.

import sys, os, re, glob, optparse

parser = optparse.OptionParser(usage="%prog [options] [filename]")
parser.add_option("-c", "--clean", action="store_true",
                  help="delete old stack files")

def main():
    options, args = parser.parse_args()
    if options.clean:
        if args:
            parser.error("filename arguments not allowed with -c or --clean")
        do_clean()
    else:
        do_show(args)
    
def do_clean():
    for name in glob.glob("hs_err_pid*.log"):
        os.remove(name)

def do_show(filenames):
    if len(filenames) == 0:
        filename = find_latest_file()
    elif len(filenames) == 1:
        filename = filenames[0]
    else:
        parser.error("too many filenames")
    frames, libs = read_frames(filename)
    print_frames(frames, libs)
    
def find_latest_file():
    # Find the most recent stack trace file.
    latestTime = None
    latestName = None
    for name in glob.glob("hs_err_pid*.log"):
        time = os.stat(name).st_mtime
        if latestTime is None or latestTime < time:
            latestTime = time
            latestName = name
    if latestName is None:
        sys.exit("No stack traces found.")
    sys.stderr.write("reading stack trace from %s\n" % latestName)
    return latestName
    
class Frame(object):
    def __init__(self, line):
        self.text = line
        match = re.match(r"C  \[([^]]+)\+0x([0-9a-f]+)\]  (\w+)\+0x([0-9a-f]+)", line)
        if match:
            self.lib, self.liboff, self.func, self.funcoff = match.groups()
        else:
            self.lib = self.liboff = self.func = self.funcoff = None

def read_frames(filename):
    frames = []
    libs = {}

    # Read the stack trace file.
    mode = None
    for line in file(filename):
        line = line.strip()
        if mode is None:
            if line.startswith("Native frames:"):
                mode = "native"
            elif line.startswith("Dynamic libraries:"):
                mode = "libs"
        elif line == "":
            mode = None
        elif mode == "native":
            frames.append(Frame(line))
        elif mode == "libs":
            filename = line.split()[-1]
            while ".so" in filename:
                libname = filename.split("/")[-1]
                libs[libname] = filename
                filename = filename[:filename.rindex(".")]

    return frames, libs

def print_frames(frames, libs):
    # Print the stack trace info.
    for frame in frames:
        print frame.text
        if frame.lib is not None:
            try:
                libfile = libs[frame.lib]
            except KeyError:
                pass
            else:
                lineinfo = os.popen("addr2line -e %s %s" % (libfile, frame.liboff)).read()
                print "   " + lineinfo.strip()

main()
